#!/usr/bin/env node

// Include our dependencies
var d3 = require('d3'),
    shapefile = require('shapefile'),
    Canvas = require('canvas'),
    Font = Canvas.Font,
    minimist = require('minimist'),
    queue = require('queue-async'),
    fs = require('fs'),
    path = require('path')

// Setup some options
var argv = minimist(process.argv.slice(2))
    input = argv.in,
    output = argv.out,
    width = argv.width || 1500,
    height = argv.height || 1500,
    index = 0,
    scale = 2,
    bbox = null

if(!input || !output)
  return console.log("Supply arguments --in SHAPEFILE --out IMAGE");

// Define output
var outfile = fs.createWriteStream(output)

var font = new Font('OpenSans', fontFile('OpenSans-Regular'))
font.addFace(fontFile('OpenSans-Semibold'),  'bold')

// Basic canvas setup
var canvas = new Canvas(width * scale, height * scale),
    context = canvas.getContext('2d'),
    projection = d3.geo.albersUsa()

// Create a path generator for drawing tracts
var path = d3.geo.path()
  .projection(projection)
  .context(context)

var povRateScale = d3.scale.sqrt()
  .domain([-95, 95])
  .range([0, 20])

// Basic styling for tracts
context.addFont(font)
context.fillStyle = '#fff'
context.strokeStyle = '#aaa'
context.lineWidth = 0.5
context.lineJoin = 'round'
context.antialias = 'subpixel'
context.font = 'bold 30px OpenSans';
context.scale(scale, scale)

// Create a solid backing
context.fillRect(0, 0, width, height)

shapefile.read(input, function render(error, collection) {
  if(error) return console.log(error)

  scaleForBoundingBox(collection.bbox)
  renderTracts(collection.features)
  renderArrows(collection.features)
  renderMeta(collection)
  canvas.pngStream().pipe(outfile)
})

//  Draw an individual tract to the canvas
//
// record - A GeoJSON feature object
//
// Returns nothing
function renderTracts(tracts) {
  for (var i = 0; i < tracts.length; i++) {
    var tract = tracts[i],
        props = tract.properties

    context.fillStyle = props.REBOUNDED != 'NA' ? 'rgba(156,205,88, 0.8)' : '#fff'

    context.beginPath()
    path(tract)
    context.fill()
    context.stroke()
  }
}

function renderArrows(tracts) {
  context.save()
  context.lineWidth = 1.0
  for (var i = 0; i < tracts.length; i++) {
    var tract = tracts[i],
        props = tract.properties,
        centroid    = path.centroid(tract),
        povRateDiff = (props.POV10RATE - props.POV70RATE).toFixed(1),
        pixelChange = povRateScale(povRateDiff)

    context.beginPath()
    if(povRateDiff >= 0) {
      context.strokeStyle = '#FF483B'
      arrow(centroid[0], centroid[1], centroid[0] + (pixelChange / .5), centroid[1] - pixelChange)
    } else {
      context.strokeStyle = '#5E5BE2'
      arrow(centroid[0], centroid[1], centroid[0] - (pixelChange / .5), centroid[1] + pixelChange)
    }

    context.stroke()
  }
  context.restore()
}

function renderMeta(collection) {
  var name = collection.features[0].properties.CBSA_TITLE,
      subtitle = "Change in poverty rate from 1970 to 2010"
      measures = context.measureText(name),
      txtWidth = measures.width,
      txtHeight = measures.actualBoundingBoxAscent + measures.actualBoundingBoxDescent,
      arrowWidth = 50


  context.fillStyle = '#222'
  context.fillText(name, (width - (txtWidth)) / 2, txtHeight + 20)

  txtWidth = context.measureText(subtitle).width
  context.font = 'normal 25px OpenSans'
  context.fillStyle = '#555'
  context.fillText(subtitle, (width - (txtWidth)) / 2, txtHeight + 55)

  context.lineWidth = 2

  context.beginPath()
  context.strokeStyle = '#FF483B'
  arrow(20, txtHeight + 3, arrowWidth, txtHeight + 3)
  context.stroke()

  context.beginPath()
  context.strokeStyle = '#5E5BE2'
  arrow(arrowWidth, txtHeight + 43, 20, txtHeight + 43)
  context.stroke()

  context.beginPath()
  context.fillStyle = 'rgba(156,205,88, 0.8)'
  context.fillRect(20, txtHeight + 70, 20, 20)

  context.fillStyle = '#333'
  context.font = 'normal 20px OpenSans'
  context.fillText('Poverty increase', arrowWidth + 20, txtHeight + 10)
  context.fillText('Poverty decrease', arrowWidth + 20, txtHeight + 50)
  context.fillText('Rebounded from poverty', arrowWidth + 20, txtHeight + 87)

  context.fillStyle = '#aaa'
  context.fillText('Justin Palmer labratrevenge.com / Source: City Observatory "Lost In Place" report cityobservatory.org', 20, height - 20)
}

// Read the header.  The complexity here is smart scaling of geometry.
//
// callback - the callback to invoke after the process is complete
//
// Returns nothing
function scaleForBoundingBox(bbox) {
  projection.scale(1).translate([0, 0])

  var g = { type: "FeatureCollection",
            features: [{ type: "Feature",
            geometry: { type: "Polygon", coordinates: [[ [ bbox[0], bbox[1] ], [ bbox[0], bbox[3] ], [ bbox[2], bbox[3] ], [ bbox[2], bbox[1] ], [ bbox[0], bbox[1] ] ]] }}]}

  b = path.bounds(g)
  s = .99 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height)
  t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2]

  projection.scale(s).translate(t)
}


// Draw an arrow on canvas.  See http://stackoverflow.com/a/6333775
function arrow(fromx, fromy, tox, toy) {
  var headlen = 6;   // length of head in pixels
  var angle = Math.atan2(toy - fromy,tox - fromx)
  context.moveTo(fromx, fromy)
  context.lineTo(tox, toy)
  context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6))
  context.moveTo(tox, toy)
  context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6))
}

function fontFile(name) {
  return path.join(__dirname, '../fonts', name + '.ttf')
}
