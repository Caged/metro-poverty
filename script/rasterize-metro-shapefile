#!/usr/bin/env node

// Include our dependencies
var d3 = require('d3'),
    shapefile = require('shapefile'),
    Canvas = require('canvas'),
    minimist = require('minimist'),
    queue = require('queue-async'),
    fs = require('fs')

// Setup some options
var argv = minimist(process.argv.slice(2))
    input = argv.in,
    output = argv.out,
    width = argv.width || 1500,
    height = argv.height || 1500,
    bbox = null

if(!input || !output)
  return console.log("Supply arguments --in SHAPEFILE --out IMAGE");

// Define output
var writer = fs.createWriteStream(output)

// Basic canvas setup
var canvas = new Canvas(width, height),
    context = canvas.getContext('2d'),
    projection = d3.geo.albersUsa()

// Create a path generator for drawing tracts
var path = d3.geo.path()
  .projection(projection)
  .context(context)
  .pointRadius(1)

var povRateScale = d3.scale.sqrt()
  .domain([-95, 95])
  .range([0, 20])

// Basic styling for tracts
context.fillStyle = '#fff'
context.strokeStyle = '#aaa'
context.lineWidth = 0.5
context.lineJoin = 'round'
context.antialias = 'subpixel'

// Create a solid backing
context.fillRect(0, 0, width, height)

shapefile.read(input, function render(error, collection) {
  if(error) return console.log(error)
  scaleForBoundingBox(collection.bbox)
  renderTracts(collection.features)
  renderArrows(collection.features)
  canvas.pngStream().pipe(writer)
})

//  Draw an individual tract to the canvas
//
// record - A GeoJSON feature object
//
// Returns nothing
function renderTracts(tracts) {
  for (var i = 0; i < tracts.length; i++) {
    var tract = tracts[i],
        props = tract.properties

    context.fillStyle = props.REBOUNDED != 'NA' ? 'rgba(156,205,88, 0.8)' : '#fff'

    context.beginPath()
    path(tract)
    context.fill()
    context.stroke()
  }
}

function renderArrows(tracts) {
  context.save()
  context.lineWidth = 1.5
  for (var i = 0; i < tracts.length; i++) {
    var tract = tracts[i],
        props = tract.properties,
        centroid    = path.centroid(tract),
        povRateDiff = (props.POV10RATE - props.POV70RATE).toFixed(1),
        pixelChange = povRateScale(povRateDiff)

    context.beginPath()
    if(povRateDiff >= 0) {
      context.strokeStyle = '#FF483B'
      arrow(centroid[0], centroid[1], centroid[0] + (pixelChange / .5), centroid[1] - pixelChange)
    } else {
      context.strokeStyle = '#5E5BE2'
      arrow(centroid[0], centroid[1], centroid[0] - (pixelChange / .5), centroid[1] + pixelChange)
    }

    context.stroke()
  }
  context.restore()
}

// Read the header.  The complexity here is smart scaling of geometry.
//
// callback - the callback to invoke after the process is complete
//
// Returns nothing
function scaleForBoundingBox(bbox) {
  projection.scale(1).translate([0, 0])

  var g = { type: "FeatureCollection",
            features: [{ type: "Feature",
            geometry: { type: "Polygon", coordinates: [[ [ bbox[0], bbox[1] ], [ bbox[0], bbox[3] ], [ bbox[2], bbox[3] ], [ bbox[2], bbox[1] ], [ bbox[0], bbox[1] ] ]] }}]}

  b = path.bounds(g)
  s = .99 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height)
  t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2]

  projection.scale(s).translate(t)
}


// Draw an arrow on canvas.  See http://stackoverflow.com/a/6333775
function arrow(fromx, fromy, tox, toy) {
  var headlen = 6;   // length of head in pixels
  var angle = Math.atan2(toy - fromy,tox - fromx)
  context.moveTo(fromx, fromy)
  context.lineTo(tox, toy)
  context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6))
  context.moveTo(tox, toy)
  context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6))
}
