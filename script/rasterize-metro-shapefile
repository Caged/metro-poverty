#!/usr/bin/env node

// Include our dependencies
var d3 = require('d3'),
    shapefile = require('shapefile'),
    Canvas = require('canvas'),
    minimist = require('minimist'),
    queue = require('queue-async'),
    fs = require('fs')

// Setup some options
var argv = minimist(process.argv.slice(2))
    input = argv.in,
    output = argv.out,
    width = argv.width || 1500,
    height = argv.height || 1500,
    bbox = null,
    count = 1

if(!input || !output)
  return console.log("Supply arguments --in SHAPEFILE --out IMAGE");

// Define IO
var reader = shapefile.reader(input || '/dev/stdin'),
    writer = fs.createWriteStream(output)

// Basic canvas setup
var canvas = new Canvas(width, height),
    context = canvas.getContext('2d'),
    projection = d3.geo.albersUsa(),
    colors = ["#9FC449",
              "#BD5BB5",
              "#AC513C",
              "#529872",
              "#666998"]

// Create a path generator for drawing tracts
var path = d3.geo.path()
  .projection(projection)
  .context(context)
  .pointRadius(1)

// Basic styling for tracts
context.fillStyle = '#fff'
context.strokeStyle = '#777'
context.lineWidth = 0.5
context.lineJoin = 'round'
context.antialias = 'subpixel'

// Kick off the rendering process
queue(1)
  .defer(readHeader)
  .defer(readAllRecords)
  .defer(close)
  .await(function(error) { if (error) throw error })

//  Draw an individual tract to the canvas
//
// record - A GeoJSON feature object
//
// Returns nothing
function drawTract(record) {
  context.beginPath()
  path(record)
  context.stroke()
}

// Read the header.  The complexity here is smart scaling of geometry.
//
// callback - the callback to invoke after the process is complete
//
// Returns nothing
function readHeader(callback) {
  reader.readHeader(function(error, header) {
    if (error) return callback(error)

    projection.scale(1).translate([0, 0])
    bbox = header.bbox

    var g = {
       type: "FeatureCollection",
       features: [{
           type: "Feature",
           geometry: {
             type: "Polygon",
             properties: null,
             coordinates: [[
                 [ bbox[0], bbox[1] ],
                 [ bbox[0], bbox[3] ],
                 [ bbox[2], bbox[3] ],
                 [ bbox[2], bbox[1] ],
                 [ bbox[0], bbox[1] ]
               ]]
           }
         }]}

    b = path.bounds(g)
    s = .99 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height)
    t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2]
    projection.scale(s).translate(t)
    callback(null)
  })
}

function readAllRecords(callback) {
  (function readRecord() {
    reader.readRecord(function(error, record) {
      if (error) return callback(error)

      if (record === shapefile.end) {
        canvas.pngStream().pipe(writer)
        return callback(null)
      }

      drawTract(record)

      count += 1
      process.nextTick(readRecord)
    })
  })()
}

function close(callback) {
  reader.close(function(error) {
    if (error) return callback(error)
    console.log('Writing ' + output + '...');
    writer.end()
    callback(null)
  })
}
