#!/usr/bin/env node

// Include our dependencies
var d3 = require('d3'),
    shapefile = require('shapefile'),
    Canvas = require('canvas'),
    Font = Canvas.Font,
    minimist = require('minimist'),
    queue = require('queue-async'),
    fs = require('fs'),
    path = require('path')

// Setup some options
var argv = minimist(process.argv.slice(2))
    input = argv.in,
    output = argv.out,
    width = argv.width || 250,
    height = argv.height || 250,
    index = 0,
    scale = 2,
    bbox = null,
    background = 'hsl(222, 10%, 8%)',
    outline    = 'hsl(222, 10%, 18%)',
    decrease   = '#85C958',
    increase   = '#C1504D'

if(!input || !output)
  return console.log("Supply arguments --in SHAPEFILE --out IMAGE");

waterFile = path.dirname(input) + '/' + path.basename(input, '.shp') + '-water.shp'

// Define output
var outfile = fs.createWriteStream(output)

var font = new Font('OpenSans', fontFile('OpenSans-Regular'))
font.addFace(fontFile('OpenSans-Semibold'),  'bold')

// Basic canvas setup
var canvas = new Canvas(width * scale, height * scale),
    context = canvas.getContext('2d'),
    projection = d3.geo.albersUsa()

// Create a path generator for drawing tracts
var path = d3.geo.path()
  .projection(projection)
  .context(context)

var povRateScale = d3.scale.threshold()
  .domain([-60, -50, -40, -30, -20, -10, 0, 10, 20, 30, 40, 50, -60])
  .range([14, 12, 10, 8, 6, 4, 2, 2, 4, 6, 8, 10, 12, 14])

// Basic styling for tracts
context.addFont(font)
context.fillStyle = background
context.strokeStyle = outline
context.lineWidth = 0.5
context.lineJoin = 'round'
context.font = 'bold 30px OpenSans';
context.scale(scale, scale)

// Create a solid backing
context.fillRect(0, 0, width, height)

shapefile.read(input, function render(error, tractGeo) {
  if(error) return console.log(error)

  scaleForBoundingBox(tractGeo.bbox)
  renderTracts(tractGeo.features)

  // Render the water for each city and generate the resulting png
  shapefile.read(waterFile, function render(error, waterGeo) {
    renderWater(waterGeo.features)
    renderArrows(tractGeo.features)
    canvas.pngStream().pipe(outfile)
  })
})

//  Draw an individual tract to the canvas
//
// record - A GeoJSON feature object
//
// Returns nothing
function renderTracts(tracts) {
  for (var i = 0; i < tracts.length; i++) {
    var tract = tracts[i],
        props = tract.properties


    context.beginPath()
    path(tract)

    context.fillStyle = d3.rgb(background).brighter(-0.5).toString()
    context.fill()
    context.stroke()
  }
}

//  Draw an individual tract to the canvas
//
// water - A GeoJSON feature object
//
// Returns nothing
function renderWater(waters) {
  for (var i = 0; i < waters.length; i++) {
    var water = waters[i]

    context.beginPath()
    path(water)

    context.fillStyle = d3.rgb(background).brighter(2).toString()
    context.fill()
  }
}

function renderArrows(tracts) {
  var extent = d3.extent(tracts, function(d) { return d.properties.POP10 / d.properties.ALAND10 })
  var lineWidthScale = d3.scale.linear()
        // one tract in chicago is an outlier, so lineWidthScale
        // clamp this to something reasonable based on other
        // poplation densities
        .domain([extent[0], Math.min(extent[1], 0.02)])
        .range([0.1, 1.0])
        .clamp(true)

  tracts = tracts
    .sort(function(a, b) { return (a.properties.POP10 / a.properties.ALAND10) - (b.properties.POP10 / b.properties.ALAND10) })

  context.save()
  for (var i = 0; i < tracts.length; i++) {
    var tract = tracts[i],
        props = tract.properties,
        centroid    = path.centroid(tract),
        povRateDiff = (props.POV10RATE - props.POV70RATE).toFixed(1),
        pixelChange = povRateScale(povRateDiff),
        lineWidth   = lineWidthScale(props.POP10 / props.ALAND10)

    context.beginPath()
    context.lineWidth = lineWidth
    if(povRateDiff >= 0) {
      context.strokeStyle = increase
      arrow(centroid[0], centroid[1], centroid[0] + (pixelChange / .5), centroid[1] - pixelChange, lineWidth * 4)
    } else {
      context.strokeStyle = decrease
      arrow(centroid[0], centroid[1], centroid[0] - (pixelChange / .5), centroid[1] + pixelChange, lineWidth * 4)
    }

    context.stroke()
  }
  context.restore()
}

// Read the header.  The complexity here is smart scaling of geometry.
//
// callback - the callback to invoke after the process is complete
//
// Returns nothing
function scaleForBoundingBox(bbox) {
  projection.scale(1).translate([0, 0])

  var g = { type: "FeatureCollection",
            features: [{ type: "Feature",
            geometry: { type: "Polygon", coordinates: [[ [ bbox[0], bbox[1] ], [ bbox[0], bbox[3] ], [ bbox[2], bbox[3] ], [ bbox[2], bbox[1] ], [ bbox[0], bbox[1] ] ]] }}]}

  b = path.bounds(g)
  s = .99 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height)
  t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2]

  projection.scale(s).translate(t)
}


// Draw an arrow on canvas.  See http://stackoverflow.com/a/6333775
function arrow(fromx, fromy, tox, toy, headlen) {
  var headlen = headlen || 3
  var angle = Math.atan2(toy - fromy,tox - fromx)
  context.moveTo(fromx, fromy)
  context.lineTo(tox, toy)
  context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6))
  context.moveTo(tox, toy)
  context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6))
}

function fontFile(name) {
  return path.join(__dirname, '../fonts', name + '.ttf')
}
